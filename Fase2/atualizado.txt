import re
import math
import argparse,sys,os,signal,time
from multiprocessing import Process, Array, Value, Semaphore


def lerFicheiro(fileName): 
    with open(fileName, 'r', encoding='utf-8') as fileRead:
        return list(filter(lambda x: x!="",fileRead.read().splitlines()))

def get_dict(palavras):
    dictPalavras = dict()
    for word in palavras:
        dictPalavras[word] = 0
    return dictPalavras

def optionA(fileRead,palavras,enable=False):

    searchResult = list()

    for linha_ficheiro in fileRead:
        containTrue = list()
        for palavra in palavras:
            if bool(re.findall(rf'\b{palavra}\b',linha_ficheiro)) == True:
                containTrue.append(True)
        if enable == False and len(containTrue) == 1:
            searchResult.append(linha_ficheiro)
        
        elif enable == True and len(containTrue) == len(palavras):
            searchResult.append(linha_ficheiro)
    return searchResult
    

def optionC(fileRead,palavras):

    dictPalavras = get_dict(palavras)

    for linha_ficheiro in fileRead:
        for word in palavras:
            palavra = word.lower()
            if bool(re.findall(rf'\b{palavra}\b',linha_ficheiro.lower())) == True:
                dictPalavras[word] += len(re.findall(rf'\b{palavra}\b',linha_ficheiro.lower()))

    return dictPalavras

def optionL(searchResult,palavras, aOptionEnable = False):

    if aOptionEnable == True:
        return len(searchResult)
    else:
        dictPalavras = get_dict(palavras)
        for linha in searchResult:
            for word in palavras:
                palavra = word.lower()
                if bool(re.findall(rf'\b{palavra}\b',linha.lower())) == True:
                    dictPalavras[word] += 1

    return dictPalavras

def pgrepwc(a,c,l,p,palavras,ficheiro,ficheiro_txt,processo):


    searchResult = optionA(ficheiro,palavras,a)
        
    if c == True:
        dictPalavrasC = optionC(ficheiro,palavras)
        imprime(ficheiro_txt,dictPalavrasC,c,l,processo)
        atualiza(dictPalavrasC,palavras)
            

    if l == True:
        dictPalavrasL = optionL(searchResult,palavras, a)
        imprime(ficheiro_txt,dictPalavrasL,c,l,processo)
        atualiza(dictPalavrasL,palavras)
    print()
        

def imprime(ficheiro,contentOption,c,l,processo):

    pt = time.gmtime()

    phoras,pminutos,psegundos,pmicrosegundos = str(pt.tm_hour),str(pt.tm_min),str(pt.tm_sec),str(pt.tm_sec * 1000000)

    global dia,mes,ano,horas,minutos,segundos,microsegundos,tamanho_ficheiros

    if leu.value == 0:
        leu.value +=1
        print()
        
        print("Início da execução da pesquisa: <"+dia+"/"+mes+"/"+ano+","+horas+":"+minutos+":"+segundos+":"+microsegundos+">")

        print()
        
        print("Número de precessos filhos: <" + str(argument.p) + ">")

        print()
        
        if argument.a == True:
            print("Opção -a ativada: Sim ")

            print()
        else:
            print("Opção -a ativada: Não ")

            print()

        print("Emissão de alarmes no intervalo de <" + str(argument.w) + "> segundos.")

        print()

    if leu_buffer.value == 0:
        leu_buffer.value +=1
        print("Processo: " + str(os.getpid()))

        print()
        
        buffer[0] = os.getpid()
    
    print(" "*15 +"ficheiro: <" + ficheiro + ">")
    print()
    print(" "*30 +"tempo de pesquisa: <"+phoras+":"+pminutos+":"+psegundos+":"+pmicrosegundos+">")
    print()
    print(" "*30 +"dimensão do ficheiro: <" + str(tamanho_ficheiros[contador.value]) + ">")
    print()

    if type(contentOption) != int:     
        for chave in contentOption:
            if type(contentOption) == dict:
                if c == True:
                    print(" "*30 +"número de ocorrências da palavra " + str(chave) + ': ' + "<" + str(contentOption[chave]) + ">")

                    print()
                else:
                    print(" "*30 +"número de linhas da palavra " + str(chave) + ': ' + "<"+ str(contentOption[chave]) + ">")
                    print()

    else:
        for palavra in argument.palavras:
            print(" "*30 +"número de linhas da palavra " + str(palavra) + ': ' + "<"+ str(contentOption) + ">")
            print()
        
    if contador.value == len(argument.f)-1:
        fpt = time.gmtime()
        fphoras,fpminutos,fpsegundos,fpmicrosegundos = str(fpt.tm_hour),str(fpt.tm_min),str(fpt.tm_sec),str(fpt.tm_sec * 1000000)
        print("Duração da execução: <"+fphoras+":"+fpminutos+":"+fpsegundos+":"+fpmicrosegundos+">")
        print()

def atualiza(contentOption,palavras):

    if type(contentOption) == dict:

        for i in range(len(palavras)):

            myArray[i] += contentOption[palavras[i]]
    else:
        myArray[0] += contentOption

def get_process():

    process.value +=1
       
def divisonTask():

    global one_file,flag

    if flag != True:

        inicio = math.ceil( ( process.value * len(one_file)) / argument.p)

        fim = math.ceil( ((process.value + 1) * len(one_file)) / argument.p)

        #print()
                    
        #print("processo ->", process.value, "intervalo ->", [inicio,fim])

        #print()

        conjunto = one_file[inicio:fim]
        
        conteudo = []

        linha_final = lista_ultima_linha[contador.value]

        ficheiro_atual = argument.f[contador.value]
        
        for l in conjunto:
                
            conteudo.append(l)

            if conta_linha.value == linha_final:
                
                pgrepwc(argument.a,argument.c,argument.l,argument.p,argument.palavras,conteudo,ficheiro_atual,process.value)

                #print(len(conteudo),ficheiro_atual)
                #print()

                conteudo = []

                if linha_final == lista_ultima_linha[len(lista_ultima_linha)-1]:
                    break
                            
                contador.value +=1
      
                linha_final = lista_ultima_linha[contador.value]
                ficheiro_atual = argument.f[contador.value]

            elif conta_linha.value == fim-1:
                pgrepwc(argument.a,argument.c,argument.l,argument.p,argument.palavras,conteudo,ficheiro_atual,process.value)
                #print(len(conteudo),ficheiro_atual)
                #print()
            conta_linha.value +=1
        get_process()
        leu_buffer.value = 0
    ocupado.release()
    

def controlC(sig,NULL):

    global flag

    flag = True
    
    sig = None

def alarm(sig,NULL):
    estado()

def estado():

    print()

    print("-" * 30 + " ATUALIZAÇÃO " + "-"*30)

    print()

    global start

    list_processados = []
    total_linhas = 0

    if argument.a == True and argument.l == True:
        print('--> O número total de linhas da pesquisa até ao momento: ' + str(myArray[0]))

    else:
        for i in range(len(argument.palavras)):

            if argument.c == True:
                print('--> A palavra ' + argument.palavras[i] + ' teve um número total de ocorrências até agora igual a: ' + str(myArray[i]))
            else:
                total_linhas += myArray[i]
            
    if argument.l == True:

        print('--> O número de linhas resultantes da pesquisa até agora: ' + str(total_linhas))

    for i in range(argument.p):

        if i < contador.value:

            list_processados.append(argument.f[i])

    if len(list_processados) == 0:
        
        print('--> Nenhum ficheiro completamente processado ainda')
    else:
        print('--> Ficheiro completamente processado: ' + str(list_processados))

    print('--> Ficheiro em processamento: ' + argument.f[contador.value] )

    print('--> Tempo decorrido: ' + str((time.time() - start)*1000000) + " em microssegundos.")

    print()

    print("-" * 30 + "-"*15 + "-"*30)

    print()
        
def final():

    print('Resultado Final: ')
    print()

    if argument.a == True and argument.l == True:
        print('O número de linhas da pesquisa no total é: ' + str(myArray[0]))
    else:
        
        for i in range(len(argument.palavras)):

            if argument.c == True:
                    print('A palavra ' + argument.palavras[i] + ' teve um número total de ocorrências igual a: ' + str(myArray[i]))

            else:
                    print('A palavra ' + argument.palavras[i] + ' teve um número total de linhas encontradas de acordo com a opção -a ' \
                          + str(argument.a) + ' igual a: ' + str(myArray[i]))    


if __name__ == '__main__':

    start = time.time()
    t = time.gmtime()

    parser = argparse.ArgumentParser()

    parser.add_argument('-a', required=False, action='store_true', help='Define se o resultado da pesquisa, caso ativo: são as linhas de texto que \
                                                                         contêm unicamente uma das palavras, caso inativo: todas as palavras ')

    parser.add_argument('-c', required=False, action='store_true', help='Opção que permite obter o número de ocorrências \
                                                                         encontradas das palavras a pesquisar')
                                                    
    parser.add_argument('-l', required=False, action='store_true', help= 'Opção que permite obter o número de linhas devolvidas da pesquisa,a. \
                                                                          Caso a opção -a não esteja ativa, o número de linhas devolvido é por palavra')
    
    parser.add_argument('-p', required=False, default=0, type=int, help='opção que permite definir o nível de paralelização, número de processos \
                                                                         (filhos)/threads que são utilizados para efetuar as pesquisas e contagens')

    parser.add_argument('-w', required=False, default=None, nargs='?', type=float, help='opção que permite definir o intervalo de tempo (dado pelo argumento s) em que o processo pai \
                                                                                                escreve para stdout o estado da contagem até ao momento.')
    
    parser.add_argument('palavras', nargs='+',help='Palavras a procurar' )

    parser.add_argument('-f',required=False, nargs='*', default = [], help='Ficheiros a serem lidos')

    argument = parser.parse_args()

    lista = sys.argv

    myArray =  Array('i',len(argument.palavras))

    if len(argument.palavras) > 3:

        print('Não pode ser mais de 3 palavras') 

    if len(argument.f) == 0:
        filesList = list()
        while len(filesList) == 0:
            print('Não colocou os ficheiros a vereficar. Quais os ficheiros que quer ler? ')
            filesList += input().split()
        argument.f = filesList

    if argument.w != None and argument.w < 0:
        print('Não existe intervalos negativos')
        exit()
        
    if argument.c == True and argument.l == True: 
        print('Não é possivel usar a opção -c em conjunto com -l')
        exit()

    elif argument.c == False and argument.l == False:
        print('Opção -c ou -l tem de estar ativa')
        exit()
    
    else:
        dia,mes,ano,horas,minutos,segundos,microsegundos = str(t.tm_mday),str(t.tm_mon),str(t.tm_year),str(t.tm_hour),str(t.tm_min),str(t.tm_sec),str(t.tm_sec * 1000000)
        
        if argument.w != None:
            signal.signal(signal.SIGALRM, alarm)
            signal.setitimer(signal.ITIMER_REAL, argument.w,argument.w)
        
        if argument.p > 0:

            one_file, lista_ultima_linha , count = [], Array('i',len(argument.f)), 0
    
            tamanho_ficheiros = []
          
            for fileName in argument.f:
                ficheiro = lerFicheiro(fileName)
                tamanho_ficheiros.append(len(ficheiro))
                
                #print(len(ficheiro))

                one_file += ficheiro
                
                lista_ultima_linha[count] = len(one_file)-1

                count +=1

            #print()

            #print(len(one_file))

            #print()
            #print(lista_ultima_linha[:])
            #print()

            contador = Value('i',0)

            #print(round(len(one_file)/argument.p))

            #print()

            conta_linha = Value('i',0)

            jobs = list()

            processados = Array("i",argument.p)

            process = Value("i",0)

            ocupado = Semaphore(1)

            flag = False

            buffer = Array("i",1)

            signal.signal(signal.SIGINT, controlC)

            leu = Value("i",0)

            leu_buffer = Value("i",0)
               
            for i in range(argument.p):

                newJ = Process(target=divisonTask)
                jobs.append(newJ)

            for job in jobs:
                
                ocupado.acquire()
                
                job.start()

            for job in jobs:
                job.join()
                                             
                        
        else:
            for ficheiro in argument.f:
                pgrepwc(argument.a,argument.c,argument.l,argument.p,argument.palavras,[ficheiro])


        final()
             
        
